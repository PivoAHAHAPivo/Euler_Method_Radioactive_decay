
    # Модуль 1
    # Установка нужных библиотек через терминал:

    # Откройте терминал и последовательно введите данные комманды
    # pip install numpy
    # pip install matplotlib
    # pip install mplcursors


    # Модуль 2
    # Подключение библиотек для построения кода

        # Подключение библиотеки numpy
import numpy as np                              # Импортирует модуль numpy и присваевает ему псевдоним np (Модуль преднозначен для введения математических функций)
        # Подключение библиотеки matplotlib
import matplotlib.pyplot as plt                 # Импортирует подмодуль pyplot из модуля matplotlib и присваевает ему псевдоним plt (Подмодуль преднозначен для визализации 
                                                #   данных при помощи графиков и их построения)
        # Подключение библиотек mplcursors
import mplcursors                               # Импортирует модуль mplcursors (Модуль предназначен для интерактивного курсора при рассмотрении графиков)


    # Модуль 3 
    # Введение возможности ввода количества ядер радиоактивных веществ для дальнейшего использования в коде

        # Подмодуль 3.1
        # Введение функции для обработки вводимых данных
def get_valid_input(prompt):                                    # Определяет функцию get_valid_input с аргументом prompt
    while True:                                                 # Условие для цикла при котором, цикл повторяется бесконечно. while это оператор цикла в Python, который повторяет
                                                                #   выполнение блока кода до тех пор, пока заданное условие истинно. True логическое значение истины (всегда истина)
        value = input(prompt)                                   # Переменная value которой пристваевается функция ввода, ввод аргумента prompt для дальнейшего использования в цикле
        if value.isdigit():                                     # Условие if value.isdigit(): которое проверяет состоит ли наш ввод только из цифер без других знаков, делая из него 
                                                                #   целое число
            value = int(value)                                  # Присваевает переменной value значение integer с аргументом value если условие if value.isdigit(): Истина
            if value > 0:                                       # Условие if value > 0: которое проверяет, является ли переменная value положительным числом
                return value                                    # Если условие if value > 0: Истина то возвращает значение value, заканчивает цикл
            elif value == 0:                                    # Условие elif value == 0: которое проверяет, является ли переменная value нулём если условие if value > 0: Ложь
                return 0                                        # Если условие if value > 0: Ложь а условие elif value == 0: Истина то возвращает значение 0, заканчивает цикл
            else:                                               # Условие else которое действует если условия if value > 0: Ложь и elif value == 0: Ложь
                print("Введите целое положительное число.")     # Выводит на консоль Введите целое положительное число. через команду print(" "), запускает цикл заново благодаря 
                                                                #   while True:
        else:                                                   # Условие else которое действует если условие if value.isdigit(): Ложь
            print("Введите целое положительное число.")         # Выводит на консоль Введите целое положительное число. через команду print(" "), запускает цикл заново благодаря
                                                                #   while True:

        # Подмодуль 3.2
        # Введение задания значений для каждого элемента
N_U_238 = get_valid_input("Введите количество ядер для N_U_238: ")          # Присваевает через функцию get_valid_input(" ") введённое значение для новой переменной N_U_238
N_Th_234 = get_valid_input("Введите количество ядер для N_Th_234: ")        # Присваевает через функцию get_valid_input(" ") введённое значение для новой переменной N_Th_234
N_Pa_234 = get_valid_input("Введите количество ядер для N_Pa_234: ")        # Присваевает через функцию get_valid_input(" ") введённое значение для новой переменной N_Pa_234
N_U_234 = get_valid_input("Введите количество ядер для N_U_234: ")          # Присваевает через функцию get_valid_input(" ") введённое значение для новой переменной N_U_234
N_Th_230 = get_valid_input("Введите количество ядер для N_Th_230: ")        # Присваевает через функцию get_valid_input(" ") введённое значение для новой переменной N_Th_230
N_Ra_226 = get_valid_input("Введите количество ядер для N_Ra_226: ")        # Присваевает через функцию get_valid_input(" ") введённое значение для новой переменной N_Ra_226
N_Rn_222 = get_valid_input("Введите количество ядер для N_Rn_222: ")        # Присваевает через функцию get_valid_input(" ") введённое значение для новой переменной N_Rn_222
N_Po_218 = get_valid_input("Введите количество ядер для N_Po_218: ")        # Присваевает через функцию get_valid_input(" ") введённое значение для новой переменной N_Po_218
N_Pb_214 = get_valid_input("Введите количество ядер для N_Pb_214: ")        # Присваевает через функцию get_valid_input(" ") введённое значение для новой переменной N_Pb_214
N_Bi_214 = get_valid_input("Введите количество ядер для N_Bi_214: ")        # Присваевает через функцию get_valid_input(" ") введённое значение для новой переменной N_Bi_214
N_Po_214 = get_valid_input("Введите количество ядер для N_Po_214: ")        # Присваевает через функцию get_valid_input(" ") введённое значение для новой переменной N_Po_214
N_Pb_210 = get_valid_input("Введите количество ядер для N_Pb_210: ")        # Присваевает через функцию get_valid_input(" ") введённое значение для новой переменной N_Pb_210
N_Bi_210 = get_valid_input("Введите количество ядер для N_Bi_210: ")        # Присваевает через функцию get_valid_input(" ") введённое значение для новой переменной N_Bi_210
N_Po_210 = get_valid_input("Введите количество ядер для N_Po_210: ")        # Присваевает через функцию get_valid_input(" ") введённое значение для новой переменной N_Po_210
N_Pb_206 = get_valid_input("Введите количество ядер для N_Pb_206: ")        # Присваевает через функцию get_valid_input(" ") введённое значение для новой переменной N_Pb_206

        # Подмодуль 3.3
        # Введение вывода введенных значений
print("Введенные значения для веществ:")        # Вывод после ввода всех значений в терминал Введенные значения для веществ:
print(f"N_U_238: {N_U_238}")                    # Вывод значения после ввода в терминал для N_U_238. Использует форматированную строку для вставки значения переменной 
                                                #   непосредственно в строку при помощи крманды print(f" : { }")
print(f"N_Th_234: {N_Th_234}")                  # Вывод значения после ввода в терминал для N_Th_234. Использует форматированную строку для вставки значения переменной 
                                                #   непосредственно в строку при помощи крманды print(f" : { }")
print(f"N_Pa_234: {N_Pa_234}")                  # Вывод значения после ввода в терминал для N_Pa_234. Использует форматированную строку для вставки значения переменной 
                                                #   непосредственно в строку при помощи крманды print(f" : { }")
print(f"N_U_234: {N_U_234}")                    # Вывод значения после ввода в терминал для N_U_234. Использует форматированную строку для вставки значения переменной 
                                                #   непосредственно в строку при помощи крманды print(f" : { }")
print(f"N_Th_230: {N_Th_230}")                  # Вывод значения после ввода в терминал для N_Th_230. Использует форматированную строку для вставки значения переменной 
                                                #   непосредственно в строку при помощи крманды print(f" : { }")
print(f"N_Ra_226: {N_Ra_226}")                  # Вывод значения после ввода в терминал для N_Ra_226. Использует форматированную строку для вставки значения переменной 
                                                #   непосредственно в строку при помощи крманды print(f" : { }")
print(f"N_Rn_222: {N_Rn_222}")                  # Вывод значения после ввода в терминал для N_Rn_222. Использует форматированную строку для вставки значения переменной 
                                                #   непосредственно в строку при помощи крманды print(f" : { }")
print(f"N_Po_218: {N_Po_218}")                  # Вывод значения после ввода в терминал для N_Po_218. Использует форматированную строку для вставки значения переменной 
                                                #   непосредственно в строку при помощи крманды print(f" : { }")
print(f"N_Pb_214: {N_Pb_214}")                  # Вывод значения после ввода в терминал для N_Pb_214. Использует форматированную строку для вставки значения переменной 
                                                #   непосредственно в строку при помощи крманды print(f" : { }")
print(f"N_Bi_214: {N_Bi_214}")                  # Вывод значения после ввода в терминал для N_Bi_214. Использует форматированную строку для вставки значения переменной 
                                                #   непосредственно в строку при помощи крманды print(f" : { }")
print(f"N_Po_214: {N_Po_214}")                  # Вывод значения после ввода в терминал для N_Po_214. Использует форматированную строку для вставки значения переменной 
                                                #   непосредственно в строку при помощи крманды print(f" : { }")
print(f"N_Pb_210: {N_Pb_210}")                  # Вывод значения после ввода в терминал для N_Pb_210. Использует форматированную строку для вставки значения переменной 
                                                #   непосредственно в строку при помощи крманды print(f" : { }")
print(f"N_Bi_210: {N_Bi_210}")                  # Вывод значения после ввода в терминал для N_Bi_210. Использует форматированную строку для вставки значения переменной 
                                                #   непосредственно в строку при помощи крманды print(f" : { }")
print(f"N_Po_210: {N_Po_210}")                  # Вывод значения после ввода в терминал для N_Po_210. Использует форматированную строку для вставки значения переменной 
                                                #   непосредственно в строку при помощи крманды print(f" : { }")
print(f"N_Pb_206: {N_Pb_206}")                  # Вывод значения после ввода в терминал для N_Pb_206. Использует форматированную строку для вставки значения переменной 
                                                #   непосредственно в строку при помощи крманды print(f" : { }")



    # Модуль 4
    # Введение их периода полураспада (Т) и расчет константы распада (альфа) радиактивных элементов для цепочки распада урана 238

U_238_hl = 10000                    # Введение переменной и присваевание ей значения периода полураспада Урана 238 в годах
U_238_dc = np.log(2) / U_238_hl     # Введение переменной константы полураспада и рассчёт её через формулу с помощью периода полураспада Урана 238 в 1/год
                                        # Альфа распад
Th_234_hl = 1500                    # Введение переменной и присваевание ей значения периода полураспада Тория 234 в годах
Th_234_dc = np.log(2) / Th_234_hl   # Введение переменной константы полураспада и рассчёт её через формулу с помощью периода полураспада Тория 234 в 1/год
                                        # Бета-минус распад
Pa_234_hl =  3000                   # Введение переменной и присваевание ей значения периода полураспада Протоактиния 234 в годах
Pa_234_dc = np.log(2) / Pa_234_hl   # Введение переменной константы полураспада и рассчёт её через формулу с помощью периода полураспада Протоактиния 234 в 1/год
                                        # Бета-минус распад
U_234_hl = 1200                     # Введение переменной и присваевание ей значения периода полураспада Урана 234 в годах
U_234_dc = np.log(2) / U_234_hl     # Введение переменной константы полураспада и рассчёт её через формулу с помощью периода полураспада Урана 234 в 1/год
                                        # Альфа распад
Th_230_hl = 2200                    # Введение переменной и присваевание ей значения периода полураспада Тория 230 в годах
Th_230_dc = np.log(2) / Th_230_hl   # Введение переменной константы полураспада и рассчёт её через формулу с помощью периода полураспада Тория 230 в 1/год
                                        # Альфа распад
Ra_226_hl = 4500                    # Введение переменной и присваевание ей значения периода полураспада Радия 226 в годах
Ra_226_dc = np.log(2) / Ra_226_hl   # Введение переменной константы полураспада и рассчёт её через формулу с помощью периода полураспада Радия 226 в 1/год
                                        # Альфа распад
Rn_222_hl = 1600                    # Введение переменной и присваевание ей значения периода полураспада Радона 222 в годах
Rn_222_dc = np.log(2) / Rn_222_hl   # Введение переменной константы полураспада и рассчёт её через формулу с помощью периода полураспада Радона 222 в 1/год
                                        # Альфа распад
Po_218_hl = 2700                    # Введение переменной и присваевание ей значения периода полураспада Полония 218 в годах
Po_218_dc = np.log(2) / Po_218_hl   # Введение переменной константы полураспада и рассчёт её через формулу с помощью периода полураспада Полония 218 в 1/год
                                        # Альфа распад
Pb_214_hl = 5500                    # Введение переменной и присваевание ей значения периода полураспада Свинца 214 в годах
Pb_214_dc = np.log(2) / Pb_214_hl   # Введение переменной константы полураспада и рассчёт её через формулу с помощью периода полураспада Свинца 214 в 1/год
                                        # Бета-минус распад
Bi_214_hl = 1600                    # Введение переменной и присваевание ей значения периода полураспада Висмута 214 в годах
Bi_214_dc = np.log(2) / Bi_214_hl   # Введение переменной константы полураспада и рассчёт её через формулу с помощью периода полураспада Висмута 214 в 1/год
                                        # Бета-минус распад
Po_214_hl = 1200                    # Введение переменной и присваевание ей значения периода полураспада Полония 214 в годах
Po_214_dc = np.log(2) / Po_214_hl   # Введение переменной константы полураспада и рассчёт её через формулу с помощью периода полураспада Полония 214 в 1/год
                                        # Альфа распад
Pb_210_hl = 3300                    # Введение переменной и присваевание ей значения периода полураспада Свинца 210 в годах
Pb_210_dc = np.log(2) / Pb_210_hl   # Введение переменной константы полураспада и рассчёт её через формулу с помощью периода полураспада Свинца 210 в 1/год
                                        # Бета-минус распад
Bi_210_hl = 2400                    # Введение переменной и присваевание ей значения периода полураспада Висмута 210 в годах
Bi_210_dc = np.log(2) / Bi_210_hl   # Введение переменной константы полураспада и рассчёт её через формулу с помощью периода полураспада Висмута 210 в 1/год
                                        # Бета-минус распад
Po_210_hl = 1100                    # Введение переменной и присваевание ей значения периода полураспада Полония 210 в годах
Po_210_dc = np.log(2) / Po_210_hl   # Введение переменной константы полураспада и рассчёт её через формулу с помощью периода полураспада Полония 210 в 1/год
                                        # Альфа распад
Pb_206_hl = np.inf                  # Введение переменной и присваевание ей значения периода полураспада Свинца 206 в годах
Pb_206_dc = 0                       # Константа распада Свинца 206 в 1/год
                                        # Стабильный элемент



    # Модуль 5
    # Введения решения системы дифференциальных уравнений первого порядка методом Эйлера и рассчёта количества Альфа и Бета частиц

        # Подмодуль 5.1
        # Введение начальных условий
alpha_particles = 0         # Начальное количество альфа частиц
beta_particles = 0          # Начальное количество бета частиц

        # Подмодуль 5.2
        # Введение возможности ввода значения времени симуляции и шага для дальнейшего использования в коде. Введения функции для обработки вводиммых значений. 
def get_valid_input_2(prompt_2):                                    # Определяет функцию get_valid_input_2 с аргументом prompt_2                                    
    while True:                                                     # Условие для цикла при котором, цикл повторяется бесконечно. while это оператор цикла в Python, который повторяет
                                                                    #   выполнение блока кода до тех пор, пока заданное условие истинно. True логическое значение истины (всегда истина)                                                  
        value_2 = input(prompt_2)                                   # Переменная value_2 которой пристваевается функция ввода, ввод аргумента prompt для дальнейшего использования в цикле
        if value_2.isdigit():                                       # Условие if value_2.isdigit(): которое проверяет состоит ли наш ввод только из цифер без других знаков, делая из него 
                                                                    #   целое число
            value_2 = int(value_2)                                  # Присваевает переменной value_2 значение integer с аргументом value если условие if value_2.isdigit(): Истина
            if value_2 > 0:                                         # Условие if value_2 > 0: которое проверяет, является ли переменная value положительным числом
                return value_2                                      # Если условие if value_2 > 0: Истина то возвращает значение value_2, заканчивает цикл                                      
            else:                                                   # Условие else которое действует если условия if value_2 > 0: Ложь
                print("Введите целое положительное число.")         # Выводит на консоль Введите целое положительное число. через команду print(" "), запускает цикл заново благодаря 
                                                                    #   while True:                                                      
        else:                                                       # Условие else которое действует если условие if value_2.isdigit(): Ложь
            print("Введите целое положительное число.")             # Выводит на консоль Введите целое положительное число. через команду print(" "), запускает цикл заново благодаря 
                                                                    #   while True:

        # Подмодуль 5.3
        # Введение задания значения для времени симуляции и шага для метода Эйлера
while True:                                                                 # Условие для цикла при котором, цикл повторяется бесконечно. while это оператор цикла в Python, 
                                                                            #   который повторяет выполнение блока кода до тех пор, пока заданное условие истинно.
                                                                            #   True логическое значение истины (всегда истина)
    T = get_valid_input_2("Время симуляции T в годах: ")                    # Присваевает через функцию get_valid_input_2(" ") введённое значение для новой переменной 
                                                                            #   T - время симуляции эксперисента               
    h = get_valid_input_2("Длина шага h в годах для метода Эйлера: ")       # Присваевает через функцию get_valid_input_2(" ") введённое значение для новой переменной 
                                                                            #   h - шаг для рассчета через метод Эйлера
    if T/h >= 100:                                                          # Условие if T/h >= 100: которое проверяет будет ли количество шагов больше ста для точности результатов 
        print(f"T: {T}")                                                    # Выводит на консоль T: Значение T через команду print(f" { }") если условие if T/h >= 100: True
        print(f"h: {h}")                                                    # Выводит на консоль h: Значение h через команду print(f" { }") если условие if T/h >= 100: True
        break                                                               # Прекращает цикл если условие if T/h >= 100: True
    else:                                                                   # Условие else которое действует если условие if T/h >= 100: Ложь
        print("Введите значения отношение которых будет больше 100.")       # Выводит на консоль Введите значения отношение которых будет больше 100. через команду print(" "), 
                                                                            #   запускает цикл заново благодаря while True:
N = T/h                                                                     # Переменная N - количества шагов, для метода Эйлера
steps = int(round(N))                                                           # Округляет по математическим правилам и присваевает тип integer переменной N
print(f"Количество шагов для метода Эйлера N = {N}")                        # Выводит на консоль Количество шагов для метода Эйлера N =  через команду print(f" { }")

        # Подмодуль 5.4
        # Введение массивов для данных
time = np.zeros(steps + 1)                  # Создает массив нулей с названием time количество нулей steps + 1 так как первая ячейка занята начальными условиями

N_U_238_arr = np.zeros(steps + 1)           # Создает массив нулей с названием N_U_238_arr количество нулей steps + 1 так как первая ячейка занята начальными условиями
N_Th_234_arr = np.zeros(steps + 1)          # Создает массив нулей с названием N_Th_234_arr количество нулей steps + 1 так как первая ячейка занята начальными условиями
N_Pa_234_arr = np.zeros(steps + 1)          # Создает массив нулей с названием N_Pa_234_arr количество нулей steps + 1 так как первая ячейка занята начальными условиями
N_U_234_arr = np.zeros(steps + 1)           # Создает массив нулей с названием N_U_234_arr количество нулей steps + 1 так как первая ячейка занята начальными условиями
N_Th_230_arr = np.zeros(steps + 1)          # Создает массив нулей с названием N_Th_230_arr количество нулей steps + 1 так как первая ячейка занята начальными условиями
N_Ra_226_arr = np.zeros(steps + 1)          # Создает массив нулей с названием N_Ra_226_arr количество нулей steps + 1 так как первая ячейка занята начальными условиями
N_Rn_222_arr = np.zeros(steps + 1)          # Создает массив нулей с названием N_Rn_222_arr количество нулей steps + 1 так как первая ячейка занята начальными условиями
N_Po_218_arr = np.zeros(steps + 1)          # Создает массив нулей с названием N_Po_218_arr количество нулей steps + 1 так как первая ячейка занята начальными условиями
N_Pb_214_arr = np.zeros(steps + 1)          # Создает массив нулей с названием N_Pb_214_arr количество нулей steps + 1 так как первая ячейка занята начальными условиями
N_Bi_214_arr = np.zeros(steps + 1)          # Создает массив нулей с названием N_Bi_214_arr количество нулей steps + 1 так как первая ячейка занята начальными условиями
N_Po_214_arr = np.zeros(steps + 1)          # Создает массив нулей с названием N_Po_214_arr количество нулей steps + 1 так как первая ячейка занята начальными условиями
N_Pb_210_arr = np.zeros(steps + 1)          # Создает массив нулей с названием N_Pb_210_arr количество нулей steps + 1 так как первая ячейка занята начальными условиями
N_Bi_210_arr = np.zeros(steps + 1)          # Создает массив нулей с названием N_Bi_210_arr количество нулей steps + 1 так как первая ячейка занята начальными условиями
N_Po_210_arr = np.zeros(steps + 1)          # Создает массив нулей с названием N_Po_210_arr количество нулей steps + 1 так как первая ячейка занята начальными условиями
N_Pb_206_arr = np.zeros(steps + 1)          # Создает массив нулей с названием N_Pb_206_arr количество нулей steps + 1 так как первая ячейка занята начальными условиями

alpha_arr = np.zeros(steps + 1)             # Создает массив нулей с названием alpha_arr количество нулей steps + 1 так как первая ячейка занята начальными условиями
beta_arr = np.zeros(steps + 1)              # Создает массив нулей с названием beta_arr количество нулей steps + 1 так как первая ячейка занята начальными условиями
                                            # Начальные данные вводит сам пользователь или они уже заданы. Например начальное условие для времени это 0.

        # Подмодуль 5.5
        # Введение начальных условий в массив
time[0] = 0                             # Задает для первой ячейки массива начальное условие для метода Эйлера

N_U_238_arr[0] = N_U_238                # Задает для первой ячейки массива начальное условие введенное нами ранее
N_Th_234_arr[0] = N_Th_234              # Задает для первой ячейки массива начальное условие введенное нами ранее
N_Pa_234_arr[0] = N_Pa_234              # Задает для первой ячейки массива начальное условие введенное нами ранее
N_U_234_arr[0] = N_U_234                # Задает для первой ячейки массива начальное условие введенное нами ранее
N_Th_230_arr[0] = N_Th_230              # Задает для первой ячейки массива начальное условие введенное нами ранее
N_Ra_226_arr[0] = N_Ra_226              # Задает для первой ячейки массива начальное условие введенное нами ранее
N_Rn_222_arr[0] = N_Rn_222              # Задает для первой ячейки массива начальное условие введенное нами ранее
N_Po_218_arr[0] = N_Po_218              # Задает для первой ячейки массива начальное условие введенное нами ранее
N_Pb_214_arr[0] = N_Pb_214              # Задает для первой ячейки массива начальное условие введенное нами ранее
N_Bi_214_arr[0] = N_Bi_214              # Задает для первой ячейки массива начальное условие введенное нами ранее
N_Po_214_arr[0] = N_Po_214              # Задает для первой ячейки массива начальное условие введенное нами ранее
N_Pb_210_arr[0] = N_Pb_210              # Задает для первой ячейки массива начальное условие введенное нами ранее
N_Bi_210_arr[0] = N_Bi_210              # Задает для первой ячейки массива начальное условие введенное нами ранее
N_Po_210_arr[0] = N_Po_210              # Задает для первой ячейки массива начальное условие введенное нами ранее
N_Pb_206_arr[0] = N_Pb_206              # Задает для первой ячейки массива начальное условие введенное нами ранее

alpha_arr[0] = alpha_particles          # Задает для первой ячейки массива начальное условие всегда 0
beta_arr[0] = beta_particles            # Задает для первой ячейки массива начальное условие всегда 0

        # Подмодуль 5.6
        # Введение метода Эйлера для рассчёта данных
for i in range(steps):                  # Условие for для каждого аргумента i в диапазоне steps
        # Ввод текущих значений на каждом шаге i для каждого элемента
    U_238 = N_U_238_arr[i]              # Переменная U_238 для каждой ячейки массива N_U_238_arr[i]
    Th_234 = N_Th_234_arr[i]            # Переменная Th_234 для каждой ячейки массива N_Th_234_arr[i]
    Pa_234 = N_Pa_234_arr[i]            # Переменная Pa_234 для каждой ячейки массива N_Pa_234_arr[i]
    U_234 = N_U_234_arr[i]              # Переменная U_234 для каждой ячейки массива N_U_234_arr[i]
    Th_230 = N_Th_230_arr[i]            # Переменная Th_230 для каждой ячейки массива N_Th_230_arr[i]
    Ra_226 = N_Ra_226_arr[i]            # Переменная Ra_226 для каждой ячейки массива N_Ra_226_arr[i]
    Rn_222 = N_Rn_222_arr[i]            # Переменная Rn_222 для каждой ячейки массива N_Rn_222_arr[i]
    Po_218 = N_Po_218_arr[i]            # Переменная Po_218 для каждой ячейки массива N_Po_218_arr[i]
    Pb_214 = N_Pb_214_arr[i]            # Переменная Pb_214 для каждой ячейки массива N_Pb_214_arr[i]
    Bi_214 = N_Bi_214_arr[i]            # Переменная Bi_214 для каждой ячейки массива N_Bi_214_arr[i]
    Po_214 = N_Po_214_arr[i]            # Переменная Po_214 для каждой ячейки массива N_Po_214_arr[i]
    Pb_210 = N_Pb_210_arr[i]            # Переменная Pb_210 для каждой ячейки массива N_Pb_210_arr[i]
    Bi_210 = N_Bi_210_arr[i]            # Переменная Bi_210 для каждой ячейки массива N_Bi_210_arr[i]
    Po_210 = N_Po_210_arr[i]            # Переменная Po_210 для каждой ячейки массива N_Po_210_arr[i]
    Pb_206 = N_Pb_206_arr[i]            # Переменная Pb_206 для каждой ячейки массива N_Pb_206_arr[i]
        # Скорость распада элементов
    dU_238_dt = -U_238_dc * U_238                           # Переменная dU_238_dt является скоростью распада U_238 и является произведением константы распада и количества ядер U_238
    dTh_234_dt = U_238_dc * U_238 - Th_234_dc * Th_234      # Переменная dTh_234_dt является скоростью распада U_238 минус произведение константы распада и количества ядер Th_234
    dPa_234_dt = Th_234_dc * Th_234 - Pa_234_dc * Pa_234    # Переменная dPa_234_dt является скоростью распада Th_234 минус произведение константы распада и количества ядер Pa_234
    dU_234_dt = Pa_234_dc * Pa_234 - U_234_dc * U_234       # Переменная dU_234_dt является скоростью распада Pa_234 минус произведение константы распада и количества ядер U_234
    dTh_230_dt = U_234_dc * U_234 - Th_230_dc * Th_230      # Переменная dTh_230_dt является скоростью распада U_234 минус произведение константы распада и количества ядер Th_230
    dRa_226_dt = Th_230_dc * Th_230 - Ra_226_dc * Ra_226    # Переменная dRa_226_dt является скоростью распада Th_230 минус произведение константы распада и количества ядер Ra_226
    dRn_222_dt = Ra_226_dc * Ra_226 - Rn_222_dc * Rn_222    # Переменная dRn_222_dt является скоростью распада Ra_226 минус произведение константы распада и количества ядер Rn_222
    dPo_218_dt = Rn_222_dc * Rn_222 - Po_218_dc * Po_218    # Переменная dPo_218_dt является скоростью распада Rn_222 минус произведение константы распада и количества ядер Po_218
    dPb_214_dt = Po_218_dc * Po_218 - Pb_214_dc * Pb_214    # Переменная dPb_214_dt является скоростью распада Po_218 минус произведение константы распада и количества ядер Pb_214
    dBi_214_dt = Pb_214_dc * Pb_214 - Bi_214_dc * Bi_214    # Переменная dBi_214_dt является скоростью распада Pb_214 минус произведение константы распада и количества ядер Bi_214
    dPo_214_dt = Bi_214_dc * Bi_214 - Po_214_dc * Po_214    # Переменная dPo_214_dt является скоростью распада Bi_214 минус произведение константы распада и количества ядер Po_214
    dPb_210_dt = Po_214_dc * Po_214 - Pb_210_dc * Pb_210    # Переменная dPb_210_dt является скоростью распада Po_214 минус произведение константы распада и количества ядер Pb_210
    dBi_210_dt = Pb_210_dc * Pb_210 - Bi_210_dc * Bi_210    # Переменная dBi_210_dt является скоростью распада Pb_210 минус произведение константы распада и количества ядер Bi_210
    dPo_210_dt = Bi_210_dc * Bi_210 - Po_210_dc * Po_210    # Переменная dPo_210_dt является скоростью распада Bi_210 минус произведение константы распада и количества ядер Po_210
    dPb_206_dt = Po_210_dc * Po_210                         # Переменная dPb_206_dt является произведением константы распада и количества ядер Po_210 и является скоростью появления Pb_206
        # Обновление количества атомов для списка
    N_U_238_arr[i + 1] = U_238 + h * dU_238_dt          # Присваевает i + 1-ой ячейке списка N_U_238_arr значение U_238 + h * dU_238_dt
    N_Th_234_arr[i + 1] = Th_234 + h * dTh_234_dt       # Присваевает i + 1-ой ячейке списка N_Th_234_arr значение Th_234 + h * dTh_234_dt
    N_Pa_234_arr[i + 1] = Pa_234 + h * dPa_234_dt       # Присваевает i + 1-ой ячейке списка N_Pa_234_arr значение Pa_234 + h * dPa_234_dt
    N_U_234_arr[i + 1] = U_234 + h * dU_234_dt          # Присваевает i + 1-ой ячейке списка N_U_234_arr значение U_234 + h * dU_234_dt
    N_Th_230_arr[i + 1] = Th_230 + h * dTh_230_dt       # Присваевает i + 1-ой ячейке списка N_Th_230_arr значение Th_230 + h * dTh_230_dt
    N_Ra_226_arr[i + 1] = Ra_226 + h * dRa_226_dt       # Присваевает i + 1-ой ячейке списка N_Ra_226_arr значение Ra_226 + h * dRa_226_dt
    N_Rn_222_arr[i + 1] = Rn_222 + h * dRn_222_dt       # Присваевает i + 1-ой ячейке списка N_Rn_222_arr значение Rn_222 + h * dRn_222_dt
    N_Po_218_arr[i + 1] = Po_218 + h * dPo_218_dt       # Присваевает i + 1-ой ячейке списка N_Po_218_arr значение Po_218 + h * dPo_218_dt
    N_Pb_214_arr[i + 1] = Pb_214 + h * dPb_214_dt       # Присваевает i + 1-ой ячейке списка N_Pb_214_arr значение Pb_214 + h * dPb_214_dt
    N_Bi_214_arr[i + 1] = Bi_214 + h * dBi_214_dt       # Присваевает i + 1-ой ячейке списка N_Bi_214_arr значение Bi_214 + h * dBi_214_dt
    N_Po_214_arr[i + 1] = Po_214 + h * dPo_214_dt       # Присваевает i + 1-ой ячейке списка N_Po_214_arr значение Po_214 + h * dPo_214_dt
    N_Pb_210_arr[i + 1] = Pb_210 + h * dPb_210_dt       # Присваевает i + 1-ой ячейке списка N_Pb_210_arr значение Pb_210 + h * dPb_210_dt
    N_Bi_210_arr[i + 1] = Bi_210 + h * dBi_210_dt       # Присваевает i + 1-ой ячейке списка N_Bi_210_arr значение Bi_210 + h * dBi_210_dt
    N_Po_210_arr[i + 1] = Po_210 + h * dPo_210_dt       # Присваевает i + 1-ой ячейке списка N_Po_210_arr значение Po_210 + h * dPo_210_dt
    N_Pb_206_arr[i + 1] = Pb_206 + h * dPb_206_dt       # Присваевает i + 1-ой ячейке списка N_Pb_206_arr значение Pb_206 + h * dPb_206_dt
        # Обновление количества альфа и бета частиц
    alpha_arr[i + 1] = alpha_arr[i] + h * (U_238_dc * U_238 + U_234_dc * U_234 + Th_230_dc * Th_230 + Ra_226_dc * Ra_226 + Rn_222_dc * Rn_222 + Po_218_dc * Po_218 + Po_214_dc * Po_214 + Po_210_dc * Po_210)
    beta_arr[i + 1] = beta_arr[i] + h * (Th_234_dc * Th_234 + Pa_234_dc * Pa_234 + Pb_214_dc * Pb_214 + Bi_214_dc * Bi_214 + Pb_210_dc * Pb_210 + Bi_210_dc * Bi_210)
            # Также как и в предыдущем абзаце присваевает i + 1-ой ячейке списка alpha_arr значение alpha_arr[i] + h * (U_238_dc * U_238 + U_234_dc * U_234 + Th_230_dc * Th_230 +
            #   + Ra_226_dc * Ra_226 + Rn_222_dc * Rn_222 + Po_218_dc * Po_218 + Po_214_dc * Po_214 + Po_210_dc * Po_210)
            # Одинаково для списка бета частиц
        # Добавление шага
    time[i + 1] = time[i] + h       # Добавляет на место i + 1 значение на месте i плюс шаг h



    # Модуль 6
    # Введение отображения графиков

        # Подмолдуль 6.1
        # Введение функции нахождения максимума графика
def find_maxima(y, t):                              # Определяет функцию find_maxima с аргументами y, t 
    maxima = []                                     # Создаёт массив под названием maxima
    for i in range(1, len(y) - 1):                  # Функция for для каждого i в диапазоне от 1 до предпоследнего, чтобы не вылезти за границы массива
        if y[i - 1] < y[i] > y[i + 1]:              # Функция if, которая определяет максимальное значение на графике
            maxima.append((t[i], y[i]))             # Добавляет в список maxima кортеж (t[i], y[i]), где t[i] это время, а y[i] это количество ядер, если условие
                                                    #   if y[i - 1] < y[i] > y[i + 1]: True 
    return maxima                                   # Возвращает переменную со значением maxima и заканчивает цикл
        # Введение функций для отображения графика  
def plot_graph(ax, x, y, label, title, color = 'blue'):         # Определяет функцию plot_graph с аргументами ax, x, y, label, title. Где x это массив значений по оси x обозначающих время.
                                                                #   y это массив значений по оси y обозначающий количество атомов. label метки для графика. title заголовок для графика.
    ax.clear()                                                  # Очистка осей перед построением нового графика
    ax.plot(x, y, label = label, color = color)                 # Строит график по данным из массивов x и y с меткой label
    ax.set_xlabel('Время (годы)')                               # Устанавливает надпись на осе x с названием Время (годы)
    ax.set_ylabel('Количество атомов')                          # Устанавливает надпись на осе y с названием Количество атомов
    ax.set_title(title)                                         # Устанавливает заголовок для каждого графика
    ax.legend()                                                 # Отображает легенду на графике
    ax.axhline(np.mean(y), color='r', linestyle='--', label='Среднее значение')
                                                                # Устанавливает среднюю линию. Добавляется горизонтальная линия на уровне среднего значения y, красного цвета с 
                                                                #   пунктирной линией и меткой Среднее значение.
    ax.legend()                                                 # Обновляет легенду и добавляет метку средней линии
    cursor = mplcursors.cursor(ax, hover = True)                # Добавляет интерактивный курсор через библиотеку mplcursors и создаёт переменную cursor. Аргумент hover = True говорит,
                                                                #   что курсор будет реагировать на наведение мыши на график
    cursor.connect("add", lambda sel: sel.annotation.set_text(f'{label}\nВремя: {sel.target[0]:.2f} лет\nКол-во: {sel.target[1]:.2e}'))
                                                    # При наведении курсора на график выдает аннотацию add при событии connect. lambda sel: это анонимная функция с аргументом выбора
                                                    #   sel который содержит информацию о выбранной точке. sel.annotation аннотация связанная с выбронной точкой данных, .set_text()
                                                    #   метод который устанавливает текст для аннотации. \n переход на новую строчку. sel.target[0]:.2f отображает данные по оси x 
                                                    #   с двумя десятичными знаками. sel.target[1]:.2e отображает данные по оси y с двумя значащими цифрами.
    maxima = find_maxima(y, x)                                  # Вводит переменную maxima и присваевает ей значение функции find_maxima(y, x)
    for t, value in maxima:                                     # Условие for для значений t, value в переменной maxima (грубо говоря сравнивает значения)
        ax.plot(t, value, 'ro')                                 # Отображает на графике в виде красной точки все локальные максимумы
    plt.draw()                                                  # Отображает график на экране
                    # Пременная  ax нужна для связи всех функций чтобы переключение графиков работало корректно и было связвнно с осями графика. Одно полотно другие оси.
        # Введение функции для отображения нескольких графиков
def plot_combined_graph(ax, x, y_dict, title):          # Определяет функцию plot_combined_graph с переменными ax, x, y_dict, title.
    ax.clear()                                          # Очистка осей перед построением нового графика
    for label, (y, color) in y_dict.items():            # Условие for для каждого label, (y, color) из словаря y_dict. y_dict.items() возвращает пары (ключ, значение) из y_dict.
                                                        #   Где label это ключ, а (y, color) это значение.
        ax.plot(x, y, label=label, color=color)         # Строит графики по данным из массивов x и y с метками label и цветами color
    ax.set_xlabel('Время (годы)')                       # Устанавливает надпись на оси x с названием Время (годы)
    ax.set_ylabel('Количество атомов')                  # Устанавливает надпись на оси y с названием Количество атомов
    ax.set_title(title)                                 # Устанавливает заголовок для графика
    ax.legend()                                         # Отображает легенду на графике
    plt.draw()                                          # Обновляет фигуру
        # Введение списка графиков
figs = [                                                                                                        # Определяет массив функций figs = []
    lambda ax: plot_graph(ax, time, N_U_238_arr, 'U-238', 'Распад U-238', color='blue'),                        
    lambda ax: plot_graph(ax, time, N_Th_234_arr, 'Th-234', 'Распад Th-234', color='green'),
    lambda ax: plot_graph(ax, time, N_Pa_234_arr, 'Pa-234', 'Распад Pa-234', color='orange'),
    lambda ax: plot_graph(ax, time, N_U_234_arr, 'U-234', 'Распад U-234', color='purple'),
    lambda ax: plot_graph(ax, time, N_Th_230_arr, 'Th-230', 'Распад Th-230', color='cyan'),
    lambda ax: plot_graph(ax, time, N_Ra_226_arr, 'Ra-226', 'Распад Ra-226', color='magenta'),
    lambda ax: plot_graph(ax, time, N_Rn_222_arr, 'Rn-222', 'Распад Rn-222', color='yellow'),
    lambda ax: plot_graph(ax, time, N_Po_218_arr, 'Po-218', 'Распад Po-218', color='brown'),
    lambda ax: plot_graph(ax, time, N_Pb_214_arr, 'Pb-214', 'Распад Pb-214', color='pink'),
    lambda ax: plot_graph(ax, time, N_Bi_214_arr, 'Bi-214', 'Распад Bi-214', color='gray'),
    lambda ax: plot_graph(ax, time, N_Po_214_arr, 'Po-214', 'Распад Po-214', color='black'),
    lambda ax: plot_graph(ax, time, N_Pb_210_arr, 'Pb-210', 'Распад Pb-210', color='red'),
    lambda ax: plot_graph(ax, time, N_Bi_210_arr, 'Bi-210', 'Распад Bi-210', color='darkblue'),
    lambda ax: plot_graph(ax, time, N_Po_210_arr, 'Po-210', 'Распад Po-210', color='darkgreen'),
    lambda ax: plot_graph(ax, time, N_Pb_206_arr, 'Pb-206', 'Распад Pb-206', color='darkorange'),
    lambda ax: plot_graph(ax, time, alpha_arr, 'Альфа частицы', 'Количество альфа частиц', color='purple'),
    lambda ax: plot_graph(ax, time, beta_arr, 'Бета частицы', 'Количество бета частиц', color='cyan'),
            # Определяет анонимную функцию lambda с аргументом ax, которая вызывает функцию plot_graph(ax, time, N__238_arr, '', 'Распад ', color=' ') с аргументом ax
    lambda ax: plot_combined_graph(ax, time, {
        'U-238': (N_U_238_arr, 'blue'),
        'Th-234': (N_Th_234_arr, 'green'),
        'Pa-234': (N_Pa_234_arr, 'orange'),
        'U-234': (N_U_234_arr, 'purple'),
        'Th-230': (N_Th_230_arr, 'cyan'),
        'Ra-226': (N_Ra_226_arr, 'magenta'),
        'Rn-222': (N_Rn_222_arr, 'yellow'),
        'Po-218': (N_Po_218_arr, 'brown'),
        'Pb-214': (N_Pb_214_arr, 'pink'),
        'Bi-214': (N_Bi_214_arr, 'gray'),
        'Po-214': (N_Po_214_arr, 'black'),
        'Pb-210': (N_Pb_210_arr, 'red'),
        'Bi-210': (N_Bi_210_arr, 'darkblue'),
        'Po-210': (N_Po_210_arr, 'darkgreen'),
        'Pb-206': (N_Pb_206_arr, 'darkorange')
    }, 'Совокупность всех элементов')               # Через функцию lambda с аргументом ax, вызывает функцию plot_combined_graph(ax, x, y_dict, title) с аргументом ax
]
        # Подмодуль 6.2
        # Введение возможности пропуска графиков
        # Определение начальных условий
current_index = 0                                               # Устанавливает начальное значение индекса в списке как 0
        # Введение функции переключения графиков
def on_click(event):                                            # Определяет функцию on_click с аргументом event (событие)
    global current_index                                        # Пременная current_index является глобальной для этой функции
    if event.dblclick:                                          # Условие if event.dblclick: при котором проверяется если было событие event. двойного нажания мыши dblclick
        current_index = (current_index + 1) % len(figs)         # Приравнивает переменную current_index к значению (current_index + 1) % len(figs). (current_index + 1) % len(figs)
                                                                #   является специальной для зацикливания графика. Делит current_index + 1 на длину списка (len(figs)) и берёт
                                                                #   её остаток. Так как длина списка на один больше чем последний индекс списка то цикл всегда имеет значения от 0 
                                                                #   до len(figs) - 1.
        figs[current_index](ax)                                 # Вызывает функцию из списка figs[] на позиции current_index с аргументом ax
        # Введение функции прекращения показа графиков
def on_key(event):                                              # Определяет функцию on_key с аргументом event (событие)
    if event.key == ' ':                                        # Условие if event,key == ' ': при котором проверяетсяесли было событие event. нажатия клавиши пробел key == ' '
        plt.close()                                             # Команда закрытия шаблона с графиками
        # Введение событий
fig, ax = plt.subplots(1, 1, figsize=(16, 9))                   # Создает фигуру и оси для построения графика через команду plt.subplots(1, 1, figsize=(16, 9))
fig.canvas.mpl_connect('key_press_event', on_key)               # fig.canvas: Объект холста (canvas) фигуры, на котором отрисовываются графики.
                                                                #   mpl_connect: Метод, который позволяет подключить обработчики событий к холсту.
                                                                #   'key_press_event': Событие, которое происходит при нажатии клавиши на клавиатуре.
                                                                #   on_key: Функция, которая будет вызвана при наступлении события 'key_press_event'. 
                                                                #   Эта функция должна быть определена заранее и принимать один аргумент — объект события.
fig.canvas.mpl_connect('button_press_event', on_click)          # 'button_press_event': Событие, которое происходит при нажатии кнопки мыши на холсте.
                                                                #   on_click: Функция, которая будет вызвана при наступлении события 'button_press_event'. 
                                                                #   Эта функция также должна быть определена заранее и принимать один аргумент — объект события.
        # Запуск первого графика
figs[current_index](ax)                                         # Вызывает функцию из списка figs[] на позиции current_index с аргументом ax
plt.show()                                                      # Вызывает отоброжение графиков построенных до этого

